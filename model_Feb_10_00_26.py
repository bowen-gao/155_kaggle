# -*- coding: utf-8 -*-
"""model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1enzH4lOBffeM9h85MmTZKXYzycqBhJBi
"""

import numpy as np
import pandas as pd
import torch
import torch.optim as optim
import torch.utils.data as data_utils

training_data =  pd.read_csv('train.csv', sep=',', header = 0, skiprows = 0, nrows=10000)
values = list(training_data.columns.values)
print(len(values))
training_Y = training_data[values[-1:]]
training_Y = np.array(training_Y, dtype='int')
training_Y = np.squeeze(training_Y)
training_X = training_data[values[0:-1]]
training_X = np.array(training_X, dtype='float32')[:, 1:]
training_X = np.nan_to_num(training_X)
training_X = torch.from_numpy(training_X)
training_Y = torch.from_numpy(training_Y)
print(training_X.shape)
print(training_Y.shape)

train = data_utils.TensorDataset(training_X, training_Y)
train_loader = data_utils.DataLoader(train, batch_size=32, shuffle=True)

N, D_in, D_out = 10000, 26, 2

model = torch.nn.Sequential(
    torch.nn.Linear(D_in, 100),
    torch.nn.ReLU(),
    torch.nn.Linear(100, 100),
    torch.nn.ReLU(),
    torch.nn.Linear(100, 100),
    torch.nn.ReLU(),
    torch.nn.Linear(100, D_out),
)

loss_fn = torch.nn.CrossEntropyLoss()
optimizer = optim.SGD(model.parameters(), lr=0.001, momentum=0.9)

for epoch in range(10):
    # Forward pass: compute predicted y by passing x to the model. Module objects
    # override the __call__ operator so you can call them like functions. When
    # doing so you pass a Tensor of input data to the Module and it produces
    # a Tensor of output data.
    running_loss = 0.0

    for i, data in enumerate(train_loader):
      inputs, labels = data

      optimizer.zero_grad()

      # forward + backward + optimize
      outputs = model(inputs)
      loss = loss_fn(outputs, labels)
      loss.backward()
      optimizer.step()




      running_loss += loss.item()/inputs.shape[0]
    
    print(epoch, running_loss)

for name, param in model.named_parameters():
    if param.requires_grad:
        print (name, param.data)

test_data =  pd.read_csv('train.csv', sep=',', header = 0, skiprows = 10000, nrows=1000)
values = list(test_data.columns.values)
print(len(values))
test_Y = test_data[values[-1:]]
test_Y = np.array(test_Y, dtype='int')
test_Y = np.squeeze(test_Y)
test_X = test_data[values[0:-1]]
test_X = np.array(test_X, dtype='float32')[:, 1:]
test_X = np.nan_to_num(test_X)
test_X = torch.from_numpy(test_X)
test_Y = torch.from_numpy(test_Y)
print(test_X.shape)
print(test_Y.shape)

test = data_utils.TensorDataset(test_X, test_Y)
test_loader = data_utils.DataLoader(test, batch_size=32, shuffle=False)

correct = 0
total = 0
with torch.no_grad():
    for data in test_loader:
        images, labels = data
        #print (images)
        #print(labels)
        outputs = model(images)
        temp, predicted = torch.max(outputs.data, 1)
        #print(outputs)
        total += labels.size(0)
        correct += (predicted == labels).sum().item()

'''
    for i in range(test_X.shape[0]):
        test_input, test_labels = test_X[i], test_Y[i]
        outputs = model(test_input)
        _, predicted = torch.max(outputs.data, 0)
        total += 1
        correct += (predicted == test_labels).sum().item()
'''
print(correct)
print(total)

print('Accuracy of the network on the test set: %d %%' % (
    100 * correct / total))

